#!/bin/sh -e

PKGMAN_NAME=pkgman
PKGMAN_ROOT="${PKGMAN_ROOT:-/}"
PKGMAN_METADATA_ROOT="${PKGMAN_METADATA_ROOT:-$PKGMAN_ROOT}"

PKGMAN_DOWNLOAD_CMD=${PKGMAN_DOWNLOAD_CMD:-curl}
PKGMAN_PATH=${PKGMAN_PATH:-$KISS_PATH}
PKGMAN_CACHE_DIR=${PKGMAN_CACHE_DIR:-${XDG_CACHE_HOME:-$HOME/.cache}/$PKGMAN_NAME}
PKGMAN_BUILD_CACHE_DIR=$PKGMAN_CACHE_DIR/build
PKGMAN_SOURCE_CACHE_DIR=${PKGMAN_SOURCE_CACHE_DIR:-$PKGMAN_CACHE_DIR/sources}

PKGMAN_METADATA_BASE_DIR=${PKGMAN_METADATA_DIR:-/var/db/$PKGMAN_NAME}
PKGMAN_METADATA_BASE_INSTALL_DIR="$PKGMAN_METADATA_BASE_DIR/install"

PKGMAN_METADATA_DIR=$PKGMAN_METADATA_ROOT/$PKGMAN_METADATA_BASE_DIR
PKGMAN_METADATA_INSTALL_DIR="$PKGMAN_METADATA_ROOT/$PKGMAN_METADATA_BASE_INSTALL_DIR"
PKGMAN_METADATA_CONFLICTS_FILE="$PKGMAN_METADATA_DIR/conflicts.txt"

PKGMAN_AUTO_INSTALL=${PKGMAN_AUTO_INSTALL:-0}
PKGMAN_FORCE=${PKGMAN_FORCE:-0}
PKGMAN_TMPDIR="${PKGMAN_TMPDIR:-/tmp/$PKGMAN_NAME}/$$"

PKGMAN_MAX_NESTED_DEPENDS="${PKGMAN_MAX_NESTED_DEPENDS:-64}"
PKGMAN_UNPRIVILEGED_USER="${PKGMAN_UNPRIVILEGED_USER:-nobody}"

PKGMAN_HOOK_PATH="${PKGMAN_HOOK_PATH:-/etc/pkgman/}"

############## General helpers
die() {
    echo "Error: $*" >&2
    exit 2
}


info() {
    echo "$@"
}

debug() {
    echo "DEBUG: $*" >&2
}

decompress() {
    case $1 in
        *.tbz|*.bz2) bzip2 -d ;;
        *.lzma)      lzma -dc ;;
        *.lz)        lzip -dc ;;
        *.tar)       cat      ;;
        *.tgz|*.gz)  gzip -d  ;;
        *.xz|*.txz)  xz -dc ;;
        *.zst)       zstd -dc ;;
    esac < "$1"
}

download_file() {
    $PKGMAN_DOWNLOAD_CMD "$1"
}

# Takes a sources file
download_sources() {
    pkg="$1"
    dest=$PKGMAN_SOURCE_CACHE_DIR/$pkg
    mkdir -p "$dest"
    while read -r url dir; do

        filename="$(basename "$url")"
        if [ -n "$dir" ]; then
            mkdir -p "$dir"
            filename="$dir/$filename"
        fi
        fullpath="$dest/$filename"
        debug "checking cache for $url"
        if [ ! -e "$fullpath" ]; then
            debug "downloading $url"
            download_file "$url" > "$fullpath.tmp"
            mv "$fullpath.tmp" "$fullpath"
        fi
        if [ -z "$dir" ]; then
            echo "$fullpath" "."
        else
            echo "$fullpath" "$dir"
        fi
    done
}

extract() {
    debug "Extracting $*"
    fullpath=$1
    destdir=$2
    [ -n "$fullpath" ] && [ -n "$destdir" ]
    case $fullpath in
        *.tar|*.tar.*)
            decompress "$fullpath" | tar -xf - -C "$destdir"
        ;;
        *.zip)
            unzip "$fullpath" -d "$destdir"
        ;;
        *)
            cp "$fullpath" "$destdir"
        ;;
    esac
}

for_each_in_path() {
    dir=$2
    # shellcheck disable=2086
    { IFS=:; set -- ${1:-"$PKGMAN_PATH"}; unset IFS; }
    for path ; do
        [ -e "$path/$dir" ] || continue
        echo "$path/$dir"
    done
}

# hooks
run_hook(){
    export TYPE="$1"
    export PKG="$2"
    debug "Running hook '$TYPE'"
    for_each_in_path "$PKGMAN_HOOK_PATH" | while read -r path; do
        for script in "$path/"*.sh; do
            if [ -x "$script" ]; then
                . "$script"
            fi
        done
    done
}

############## Read state of packages in repo
pkg_read_version() {
    path=$1
    full_version=${2:-0}
    read -r version rep <"$path/version"
    if [ "$full_version" -eq 0 ]; then
        echo "$version"
    elif [ "$full_version" -eq 1 ]; then
        echo "${version}_$rep"
    else
        echo "$version $rep"
    fi
}

pkg_read_full_version() {
    pkg_read_version "$1" 1
}

pkg_read_raw_version() {
    pkg_read_version "$1" 2
}

# Searches "$PKGMAN_PATH" for the specified package
pkg_find() {
    target=$1
    pkg="$(for_each_in_path "$PKGMAN_PATH" "$target" | head -n1)"
    [ -n "$pkg" ] || return 1
    echo "$pkg"
}

pkg_fetch() {
    for_each_in_path "$PKGMAN_PATH" ".git" | while read -r path; do
        (
            cd "$path/.."

            run_hook pre-fetch

            git pull --rebase

            run_hook post-fetch

        ) || die "Failed to pull $path"
    done
}

pkg_search() {
    target=$1
    for_each_in_path "$PKGMAN_PATH" | while read -r path; do
        for pkg in "$path"/*; do
            [ -d "$pkg" ] && echo "$pkg"
        done
    done | grep "$target"
}

pkg_read_sources() {
    path=$1
    pkg="$(basename "$1")"
    version=$2
    for file in "$path/sources" "$path/.sources"; do
        [ -r "$file" ] || continue
        sed '/^#/d; /^$/d' "$file" |
        sed -e "s/ARCH/$(uname -m)/g" -e "s/VERSION/$version/g" -e "s/PACKAGE/$pkg/g"
    done
}

_pkg_find_nested_deps() {
    path=$1
    pkg="$(basename "$1")"
    max_level=$2
    level=$3
    if [ "$level" -ne 0 ]; then
        for _ in $(seq 1 "$level"); do
           printf "\t"
        done
    fi
    [ -r "$1/depends" ] || return 0
    while read -r depend label; do
        [ "#${depend#"#"}" = "$depend" ] && continue
        [ -z "$depend" ] && continue
        printf "%s\t%s\n" "$depend" "$label"
        if [ "$max_level" -ne "$level" ]; then
            dep_path=$(pkg_find "$depend")
            _pkg_find_nested_deps "$dep_path" "$max_level" "$((level+1))"
        fi
    done <"$1/depends"
}

pkg_find_nested_deps() {
    SED_PATTERN=${2:+"/\s$2\$/d"}
    max_level=${3:-"$PKGMAN_MAX_NESTED_DEPENDS"}
    level=${4:-0}
    _pkg_find_nested_deps "$1" "$max_level" "$level" | sed "$SED_PATTERN"
}

pkg_find_deps() {
    pkg_find_nested_deps "$1" "$2" 0 0
}

############## Read PKGMANGAGER specific state

# Outputs the built tar; fails if package isn't built
pkg_is_built() {
    pkg=$1
    version=$2
    if [ -z "$2" ]; then
        path=$(pkg_find "$pkg")
        version="$(pkg_read_full_version "$path")"
    fi
    archive="$PKGMAN_BUILD_CACHE_DIR/${pkg}_${version}.tar"
    [ -e "$archive" ] || return 2
    echo "$archive"
}

# Outputs the built tar; exits if package isn't built
pkg_get_built() {
    pkg_is_built "$1" "$2" || die "Package not built"
}

# Returns success if packages is installed
pkg_is_installed() {
    [ -d "$PKGMAN_METADATA_INSTALL_DIR/$1" ]
}

# Outputs the version of the installed package if package is installed
pkg_get_installed_version() {
    [ -e "$PKGMAN_METADATA_INSTALL_DIR/$1/version" ] && {
        read -r v r < "$PKGMAN_METADATA_INSTALL_DIR/$1/version"
        echo "${v}_${r}"
    }
}

# Business logic

pkg_download() {
    pkg=$1
    path=$2
    version=$3
    pkg_read_sources "$path" "$version" | grep "^\w*://" | download_sources "$pkg"
}

pkg_extract_sources() {
    debug "Extracting sources $*"
    pkg=$1
    dest=$2
    path=$3
    [ -n "$path" ] || path="$(pkg_find "$pkg")"
    version=$(pkg_read_version "$path")

    # Download sources first to verify we can download them
    pkg_download "$pkg" "$path" "$version" >/dev/null

    # Handle git repo next since we can't clone into a non-empty dir
    pkg_read_sources "$path" "$version" | grep "^git+" | while read -r rpath dirname; do
        git clone "${rpath#git+}" "$dest/$dirname"
    done

    pkg_download "$pkg" "$path" "$version" | while read -r fullpath dirname; do
        mkdir -p "$dest/$dirname"
        tmp="$path/.tmp"
        mkdir -p "$tmp"
        extract "$fullpath" "$tmp"
        # shellcheck disable=2144
        if [ -d "$tmp"/* ]; then
            mv "$tmp"/*/* "$dest/$dirname"
            rmdir "$path/.tmp"/*
        else
            mv "$tmp" "$dest/$dirname"
        fi
    done

    # Handle local files last so they can override any of the above in case of conflicts
    pkg_read_sources "$path" "$version" | grep -v -e "^\w*://" -e "^git+"| while read -r rpath dirname; do
        if [ "git+${rpath#git+}" = "$rpath" ]; then
            git clone "${rpath#git+}" "$dest/$dirname"
        else
            cp "$path/$rpath"  "$dest/$dirname"
        fi
    done
}

pkg_gen_manifest() {
    find "$1" | sed -e "s:$1::" -e '/^$/d' | sort
}

pkg_build_helper() {
    pkg=$1
    path=$(pkg_find "$pkg")
    [ -x "$path/build" ]
    WORKING_DIR="$PKGMAN_TMPDIR/$pkg"
    mkdir -p  "$WORKING_DIR"
    trap 'rm -rf $WORKING_DIR' EXIT
    DEST_DIR="$WORKING_DIR/dest"
    BUILD_DIR="$WORKING_DIR/build"
    mkdir -p "$BUILD_DIR" "$DEST_DIR"
    pkg_extract_sources "$pkg" "$BUILD_DIR" "$path"
    cd "$BUILD_DIR"

    run_hook pre-build "$pkg"

    # actually build
    # shellcheck disable=2046
    "$path/build" "$DEST_DIR" $(pkg_read_raw_version "$path" )
    METADATA_DIR="$DEST_DIR/$PKGMAN_METADATA_BASE_INSTALL_DIR/$pkg"
    mkdir -p "$METADATA_DIR"
    cp -R "$path"/* "$METADATA_DIR"

    cd "$DEST_DIR"
    run_hook post-build "$pkg"

    # todo hooks
    pkg_gen_manifest "$DEST_DIR" > "$METADATA_DIR/manifest"
    version="$(pkg_read_full_version "$path")"
    tar -c -C "$DEST_DIR" . > "$PKGMAN_BUILD_CACHE_DIR/${pkg}_${version}.tar"
}

pkg_build_single() {
    pkg=$1
    info "building $pkg"
    if [ "$(whoami)" != root ]; then
        ( pkg_build_helper "$pkg" )
    else
        echo "$0" _pkg_build_helper "$pkg" | {
            if [ "$USER" = root ]; then
                exec su "$PKGMAN_UNPRIVILEGED_USER"
            else
                exec su "$USER"
            fi
        }
    fi
    info "built $pkg"
}

pkg_build_depedencies() {
    pkg=$1
    filterStr=$2
    level=${3:-0}
    pkg_find_deps "$pkg" "$filterStr" |
    while read -r dep_pkg _; do
        if ! pkg_is_installed "$dep_pkg"; then
            if ! pkg_is_built "$dep_pkg" >/dev/null; then
                [ "$level" -ne "$PKGMAN_MAX_NESTED_DEPENDS" ] || die "Too many nested dependencies"
                pkg_build_depedencies "$dep_pkg" "" "$((level+1))"
                pkg_build_single "$dep_pkg"
            fi
            pkg_install "$dep_pkg"
        fi
    done
}

pkg_build() {
    pkg_build_depedencies "$pkg"
    pkg_build_single "$pkg"
}

pkg_install_helper() {
    pkg=$1
    archive=$2
    WORKING_DIR="$(mktemp -d)"
    EXTRACTION_DIR="$WORKING_DIR/_fakeroot"
    trap 'rm -rf $WORKING_DIR' EXIT
    mkdir -p "$EXTRACTION_DIR"

    METADATA_DIR="$PKGMAN_METADATA_BASE_INSTALL_DIR/$pkg"
    RELATIVE_METADATA_DIR=".$METADATA_DIR"
    MANIEFST="$EXTRACTION_DIR/$RELATIVE_METADATA_DIR/manifest"

    extract "$archive" "$EXTRACTION_DIR"

    PREVIOUS_MANIFEST=$WORKING_DIR/current_manifest
    cp "$PKGMAN_METADATA_INSTALL_DIR/$pkg/manifest" "$PREVIOUS_MANIFEST" 2>/dev/null || true

    cd "$EXTRACTION_DIR"
    run_hook pre-install "$pkg" "$PREVIOUS_MANIFEST"

    cp -R "$EXTRACTION_DIR"/* "$PKGMAN_ROOT"
    # Update manifest because hooks may have changed it
    pkg_gen_manifest "$EXTRACTION_DIR" > "$PKGMAN_METADATA_INSTALL_DIR/$pkg/manifest"

    if [ -r "$PREVIOUS_MANIFEST" ]; then
        comm -13 "$PKGMAN_METADATA_INSTALL_DIR/$pkg/manifest" "$PREVIOUS_MANIFEST" | while read -r path; do
            rm "$PKGMAN_ROOT/$path"
        done
    fi

    cd "$PKGMAN_METADATA_INSTALL_DIR/$pkg"
    run_hook post-install "$pkg"
}

pkg_install() {
    pkg=$1
    path=$(pkg_find "$pkg")
    version="$(pkg_read_full_version "$path")"
    archive="$PKGMAN_BUILD_CACHE_DIR/${pkg}_${version}.tar"
    info "installing $pkg"

    # ensure non-make dependencies are built
    pkg_build_depedencies "$pkg" make
    if ! pkg_is_built "$pkg" >/dev/null; then
        pkg_build "$pkg"
    fi

    archive="$(pkg_get_built "$pkg" "$version")"
    mkdir -p "$PKGMAN_METADATA_INSTALL_DIR"
    touch "$PKGMAN_METADATA_CONFLICTS_FILE"
    flock "$PKGMAN_METADATA_CONFLICTS_FILE" "$0" _pkg_install_helper "$pkg" "$archive"

    info "installed $pkg"
}

pkg_remove() {
    pkg=$1
    MANIEFST="$PKGMAN_METADATA_INSTALL_DIR/$pkg/manifest"
    [ -e "$MANIEFST" ] || die "Package not installed"

    info "Removing $pkg"
    sort -r "$MANIEFST" | while read -r file; do
        if [ -d "$PKGMAN_ROOT/$file" ]; then
            rmdir "$PKGMAN_ROOT/$file" 2>/dev/null || true
        else
            rm -f "$PKGMAN_ROOT/$file"
        fi
    done

    info "Removed $pkg"

}

pkg_list_installed() {
    [ $# -eq 0 ] && set -- "$PKGMAN_METADATA_INSTALL_DIR/"*
    for path ; do
        if [ -d "$path" ]; then
            pkg=${path#"$PKGMAN_METADATA_INSTALL_DIR/"}
            read -r v r < "$PKGMAN_METADATA_INSTALL_DIR/$pkg/version"
            printf "%s\t%s\n" "$pkg" "$v $r"
        fi
    done
}

############ External commands

action_fork() {
    for pkg do
        [ ! -d "$pkg" ]
        path=$(pkg_find "$pkg")
        mkdir "$pkg"
        cp -R "$path" "$pkg"
    done
}

action_find() {
    for pkg do
        pkg_find "$pkg"
    done
}
action_search() {
    for pattern do
        pkg_search "$pattern"
    done
}

action_download() {
    for pkg do
        pkg=$1
        path=$(pkg_find "$pkg" 1)
        version=$(pkg_read_version "$path")
        pkg_download "$pkg" "$path" "$version"
    done
}

action_extract_sources() {
    for pkg do
        pkg_extract_sources "$pkg" "${PKG_DESTDIR:-"$PWD/$pkg"}"
    done
}


_get_build_order() {
    # shellcheck disable=2030
    {
        if [ $# -eq 0 ]; then
            while read -r pkg; do
                echo "$(pkg_find_nested_deps "$pkg" | sort -u | wc -l) $pkg"
            done
        else
            for pkg do
                echo "$(pkg_find_nested_deps "$pkg" | sort -u | wc -l) $pkg"
            done
        fi
    } | sort -n | cut -d" " -f2
}

action_depends () {
    pkg_find_deps "$1"
}

action_tree () {
    pkg_find_nested_deps "$1"
}

action_build() {
    # shellcheck disable=2046
    set -- $(_get_build_order "$@")
    mkdir -p "$PKGMAN_BUILD_CACHE_DIR"
    for pkg do
        pkg_build "$pkg"
    done
}

action_export() {
    archive="$(pkg_get_built "$@")"
    cp "$archive" "${PKG_DESTDIR:-.}/"
}

action_install() {
    mkdir -p "$PKGMAN_BUILD_CACHE_DIR"
    for pkg do
        pkg_install "$pkg"
    done
}
action_manifest () {
    for pkg do
        METADATA_DIR="$PKGMAN_METADATA_BASE_INSTALL_DIR/$pkg"
        cat "RELATIVE_METADATA_DIR/manifest"
    done
}

pkg_determine_out_of_date() {
    pkg_list_installed | while read -r pkg v r; do
        if [ "${v}_${r}" != "$(pkg_read_full_version "$pkg")" ]; then
            echo "$pkg"
        fi
    done
}

action_outdated() {
    pkg_determine_out_of_date | _get_build_order
}
action_fetch() {
    pkg_fetch
}

pkg_revdepends() {
    grep -lEs -- "^$1(\s|\$)" "$PKGMAN_METADATA_INSTALL_DIR/"*/depends | while read -r file; do
        relative_path=${file#"$PKGMAN_METADATA_INSTALL_DIR/"}
        pkg=${relative_path%"/depends"}
        if [ "${pkg#"__"}" = "$pkg" ]; then
            grep -E "^$1( |\$)" "$file" | {
                read -r _ label
                printf "%s\t%s\n" "$pkg" "$label"
            }
        fi
    done
}

action_revdepends() {
    for pkg do
        pkg_revdepends "$pkg"
    done
}

action_remove() {
    for pkg do
        if [ "$PKGMAN_FORCE" -eq 0 ] && pkg_revdepends "$pkg" | grep -q -v "make"; then
            die "$pkg has dependents"
        fi
        pkg_remove "$pkg"
    done
}

action_list() {
    if [ $# -eq 0 ]; then
        pkg_list_installed
    else
        [ -d "$PKGMAN_METADATA_INSTALL_DIR" ] || return 1
        cd "$PKGMAN_METADATA_INSTALL_DIR/"
        for pattern ; do
            echo * | xargs -n1 | grep -x "$pattern" | while read -r pkg; do
                if pkg_is_installed "$pkg"; then
                    pkg_list_installed "$PKGMAN_METADATA_INSTALL_DIR/$pkg"
                elif [ "${PKGMAN_KEEP_GOING:-0}" -eq 0 ]; then
                    die "Could not find $pkg $pattern"
                fi
            done
        done
    fi
}

action_manifest() {
    for pkg do
        cat "$PKGMAN_METADATA_INSTALL_DIR/$pkg/manifest"
    done
}

pkg_ext() {
    name=$1
    for_each_in_path "$PATH" | while read -r path; do
        if [ -x "$path/$name" ]; then
            printf "%s\t%s\n" "$name" "$path/$name"
            return
        else
            for executable in "$path/$name"*; do
                if [ -x "$executable" ]; then
                    printf "%s\t%s\n" "${executable#"$path/"}" "$executable"
                fi
            done
        fi
    done
}

action_ext() {
    if [ $# -eq 0 ]; then
        pkg_ext pkgmanager- | sort -u -k1
    else
        name="pkgmanager-$1"
        shift
        path=$(pkg_ext "$name" | head -n1 | cut -f1)
        [ -n "$path" ]
        debug "Using $path"
        exec $path "$@"
    fi
}

action=$1
shift
case "$action" in
    _pkg_build_helper) pkg_build_helper "$@";;
    _pkg_install_helper) pkg_install_helper "$@";;
    b|build) action_build "$@";;
    do*) action_download "$@";;
    export)    action_export "$@";;
    e|extract) action_extract_sources "$@";;
    d|depends) action_depends "$@";;
    t|tree) action_tree "$@";;
    find) action_find "$@";;
    fetch) action_fetch "$@";;
    i|install) action_install "$@";;
    l|list) action_list "$@";;
    f|fork) action_fork "$@";;
    outdated) action_outdated "$@";;
    mani*) action_manifest  "$@";;
    r|remove) action_remove "$@";;
    rev*) action_revdepends "$@";;
    s|search) action_search "$@";;
    list-ext) action_ext;;
    get-metadata-install-dir) echo "$PKGMAN_METADATA_INSTALL_DIR/$1";;
    *) action_ext "$action" "$@" ;;
esac
