#!/bin/sh -e

PKGMAN_NAME=pkgman
PKGMAN_ROOT="${PKGMAN_ROOT:-/}"
PKGMAN_METADATA_ROOT="${PKGMAN_METADATA_ROOT:-$PKGMAN_ROOT}"

PKGMAN_DOWNLOAD_CMD=${PKGMAN_DOWNLOAD_CMD:-curl}
PKGMAN_PATH=${PKGMAN_PATH:-$KISS_PATH}
PKGMAN_CACHE_DIR=${PKGMAN_CACHE_DIR:-${XDG_CACHE_HOME:-$HOME/.cache}/$PKGMAN_NAME}
PKGMAN_BUILD_CACHE_DIR=$PKGMAN_CACHE_DIR/build
PKGMAN_SOURCE_CACHE_DIR=${PKGMAN_SOURCE_CACHE_DIR:-$PKGMAN_CACHE_DIR/sources}

PKGMAN_METADATA_BASE_DIR=${PKGMAN_METADATA_DIR:-/var/db/$PKGMAN_NAME}
PKGMAN_METADATA_BASE_INSTALL_DIR="$PKGMAN_METADATA_BASE_DIR/install"

PKGMAN_METADATA_DIR=$PKGMAN_METADATA_ROOT/$PKGMAN_METADATA_BASE_DIR
PKGMAN_METADATA_INSTALL_DIR="$PKGMAN_METADATA_ROOT/$PKGMAN_METADATA_BASE_INSTALL_DIR"
PKGMAN_METADATA_CONFLICTS_FILE="$PKGMAN_METADATA_DIR/conflicts.txt"

PKGMAN_AUTO_INSTALL=${PKGMAN_AUTO_INSTALL:-0}
PKGMAN_FORCE=${PKGMAN_FORCE:-0}
PKGMAN_TMPDIR="${PKGMAN_TMPDIR:-/tmp/$PKGMAN_NAME}/$$"


############## General helpers
die() {
    echo "Error: $*" >&2
    exit 2
}


info() {
    echo "$@"
}

debug() {
    echo "DEBUG: $*" >&2
}

decompress() {
    case $1 in
        *.tbz|*.bz2) bzip2 -d ;;
        *.lzma)      lzma -dc ;;
        *.lz)        lzip -dc ;;
        *.tar)       cat      ;;
        *.tgz|*.gz)  gzip -d  ;;
        *.xz|*.txz)  xz -dc ;;
        *.zst)       zstd -dc ;;
    esac < "$1"
}

download_file() {
    $PKGMAN_DOWNLOAD_CMD "$1"
}

# Takes a sources file
download_sources() {
    pkg="$1"
    dest=$PKGMAN_SOURCE_CACHE_DIR/$pkg
    mkdir -p "$dest"
    while read -r url dir; do
        if [ "${url#git+}" != "$url" ] ; then
            if [ -n "$GIT_CLONE_DEST" ]; then
                debug "cloneing $url"
                # shellcheck disable=2086
                ( cd "$GIT_CLONE_DEST" && git clone "${url#git+}" $dir )
            fi
            continue
        fi

        filename="$(basename "$url")"
        if [ -n "$dir" ]; then
            mkdir -p "$dir"
            filename="$dir/$filename"
        fi
        fullpath="$dest/$filename"
        debug "checking cache for $url"
        if [ ! -e "$fullpath" ]; then
            debug "downloading $url"
            download_file "$url" > "$fullpath.tmp"
            mv "$fullpath.tmp" "$fullpath"
        fi
        if [ -z "$dir" ]; then
            echo "$fullpath" "."
        else
            echo "$fullpath" "$dir"
        fi
    done
}

extract() {
    debug "Extracting $*"
    fullpath=$1
    destdir=$2
    [ -n "$fullpath" ] && [ -n "$destdir" ]
    case $fullpath in
        *.tar|*.tar.*)
            decompress "$fullpath" | tar -xf - -C "$destdir"
        ;;
        *.zip)
            unzip "$fullpath" -d "$destdir"
        ;;
        *)
            cp "$fullpath" "$destdir"
        ;;
    esac
}


############## Read state of packages in repo
pkg_read_version() {
    path=$1
    full_version=${2:-0}
    for file in "$path/version" "$path/.version"; do
        [ -r "$file" ] || continue
        read -r version rep <"$file"
        if [ "$full_version" -eq 0 ]; then
            echo "$version"
        else
            echo "${version}_$rep"
        fi
        break
    done
}

pkg_read_full_version() {
    pkg_read_version "$1" 1
}

# Searches "$PKGMAN_PATH" for the specified package
pkg_find() {
    target=$1
    { IFS=:; set -- "$PKGMAN_PATH"; unset IFS; }
    for path in $PKGMAN_PATH; do
        [ -d "$path" ] || continue
        if [ -d "$path/$target" ]; then
            echo "$path/$target"
            return 0
        fi
    done
    return 1;
}

pkg_search() {
    target=$1
    { IFS=:; set -- "$PKGMAN_PATH"; unset IFS; }
    for path in $PKGMAN_PATH; do
        [ -d "$path" ] || continue
        for pkg in "$path"/*; do
            [ -d "$pkg" ] && echo "$pkg"
        done
    done | grep "$target"
}

pkg_read_sources() {
    path=$1
    pkg="$(basename "$1")"
    version=$2
    for file in "$path/sources" "$path/.sources"; do
        [ -r "$file" ] || continue
        sed -e "s/ARCH/$(uname -m)/g" -e "s/VERSION/$version/g" -e "s/PACKAGE/$pkg/g" "$file"
    done
}

pkg_find_nested_deps() {
    path=$1
    pkg="$(basename "$1")"
    level=${2:-0}
    if [ "$level" -ne 0 ]; then
        for _ in $(seq 1 "$level"); do
           printf "\t"
        done
    fi
    for file in "$1/depends" "$1/.depends"; do
        [ -r "$file" ] || continue
        while read -r depend _; do
            dep_path=$(pkg_find "$depend")
            pkg_find_nested_deps "$dep_path" "$((level+1))"
        done <"$file"
    done
}

############## Read PKGMANGAGER specific state

# Outputs the built tar; fails if package isn't built
pkg_is_built() {
    pkg=$1
    version=$2
    if [ -z "$2" ]; then
        path=$(pkg_find "$pkg")
        version="$(pkg_read_full_version "$path")"
    fi
    archive="$PKGMAN_BUILD_CACHE_DIR/${pkg}_${version}.tar"
    [ -e "$archive" ]
    echo "$archive"
}

# Outputs the built tar; exits if package isn't built
pkg_get_built() {
    pkg_is_built "$1" "$2" || die "Package not built"
}

# Returns success if packages is installed
pkg_is_installed() {
    [ -d "$PKGMAN_METADATA_INSTALL_DIR/$1" ]
}

# Outputs the version of the installed package if package is installed
pkg_get_installed_version() {
    [ -e "$PKGMAN_METADATA_INSTALL_DIR/$1/version" ] && cat "$PKGMAN_METADATA_INSTALL_DIR/$1/version"
}

# Business logic

pkg_download() {
    pkg=$1
    path=$2
    version=$3
    pkg_read_sources "$path" "$version" | grep -v "^git+" | download_sources "$pkg"
}

pkg_extract_sources() {
    debug "Extracting sources $*"
    pkg=$1
    dest=$2
    path=$3
    [ -n "$path" ] || path="$(pkg_find "$pkg")"
    version=$(pkg_read_version "$path")
    GIT_CLONE_DEST="$3"
    pkg_download "$pkg" "$path" "$version" >/dev/null
    pkg_download "$pkg" "$path" "$version" | while read -r fullpath dirname; do
        mkdir -p "$dest/$dirname"
        extract "$fullpath" "$dest/$dirname"
    done
    unset GIT_CLONE_DEST
}


pkg_owns() {
    filepath=$1
    manifest=$(grep "$filepath" "$PKGMAN_METADATA_INSTALL_DIR/"*/manifest | head -n1)
    basename "$(dirname "$manifest")"
}


pkg_build_helper() {
    pkg=$1
    path=$(pkg_find "$pkg")
    [ -r "$path/build" ] || return
    [ -x "$path/build" ]
    (
        WORKING_DIR="$PKGMAN_TMPDIR/$pkg"
        mkdir -p  "$WORKING_DIR"
        trap 'rm -rf $WORKING_DIR' EXIT
        DEST_DIR="$WORKING_DIR/dest"
        BUILD_DIR="$WORKING_DIR/build"
        mkdir -p "$BUILD_DIR" "$DEST_DIR"
        pkg_extract_sources "$pkg" "$BUILD_DIR" "$path"
        cd "$BUILD_DIR"
        # actually build
        "$path/build" "$DEST_DIR"
        METADATA_DIR="$DEST_DIR/$PKGMAN_METADATA_BASE_INSTALL_DIR/$pkg"
        mkdir -p "$METADATA_DIR"
        cp -R "$path"/* "$METADATA_DIR"
        # todo hooks
        find "$DEST_DIR" -depth | sed -e "s:$DEST_DIR::" -e '/^$/d' > "$METADATA_DIR/manifest"
        version="$(pkg_read_full_version "$path")"
        tar -c -C "$DEST_DIR" . > "$PKGMAN_BUILD_CACHE_DIR/${pkg}_${version}.tar"
    )
}

pkg_build() {
    pkg=$1
    info "building $pkg"
    pkg_build_helper "$pkg"
    info "built $pkg"

}

pkg_install_helper() {
    pkg=$1
    archive=$2
    # TODO consider flocking
    (
        WORKING_DIR="$(mktemp -d)"
        trap 'rm -rf $WORKING_DIR' EXIT
        METADATA_DIR="$PKGMAN_METADATA_BASE_INSTALL_DIR/$pkg"
        RELATIVE_METADATA_DIR=".$METADATA_DIR"
        MANIEFST="$RELATIVE_METADATA_DIR/manifest"
        cd "$WORKING_DIR"
        tar -xf "$archive" "$MANIEFST"
        TEMP_CONFLICTS=conficts
        touch "$TEMP_CONFLICTS"
        while read -r file; do
            [ ! -d "$file" ] || continue
            if [ -e "$file" ]; then
                if pkg_owns "$file" >/dev/null && [ "$(pkg_owns "$file")" != "$pkg" ]; then
                    echo "$pkg $file" > "$TEMP_CONFLICTS"
                    continue
                fi
            fi
            tar -xf "$archive" -C "$PKGMAN_ROOT" ".$file"
        done < "$MANIEFST"
        cut -d" " -f2 <"$TEMP_CONFLICTS" | grep -v -Ff- "$MANIEFST" > "$PKGMAN_ROOT/$MANIEFST"
        debug "Updating conflicts"
        touch "$PKGMAN_METADATA_CONFLICTS_FILE"
        grep -v "$pkg " "$PKGMAN_METADATA_CONFLICTS_FILE" | sort -u - "$TEMP_CONFLICTS" > temp
        mv temp "$PKGMAN_METADATA_CONFLICTS_FILE"
    )
}

pkg_install() {
    pkg=$1
    path=$(pkg_find "$pkg")
    version="$(pkg_read_full_version "$path")"
    archive="$PKGMAN_BUILD_CACHE_DIR/${pkg}_${version}.tar"
    force=${2:-0}
    info "installing $pkg"

    archive="$(pkg_get_built "$pkg" "$version")"
    if [ "$force" -eq 0 ] && [ "$(pkg_get_installed_version "$pkg")" = "$version" ]; then
        return
    fi
    pkg_install_helper "$pkg" "$archive"

    info "installed $pkg"
}

pkg_remove() {
    pkg=$1
    MANIEFST="$PKGMAN_METADATA_INSTALL_DIR/$pkg/manifest"
    [ -e "$MANIEFST" ] || die "Package not installed"

    info "Removing $pkg"
    while read -r file; do
        echo "FILE $file"
        if [ -d "$PKGMAN_ROOT/$file" ]; then
            rmdir "$PKGMAN_ROOT/$file" || true
        else
            rm -f "$PKGMAN_ROOT/$file"
        fi
    done < "$MANIEFST"

    info "Removed $pkg"

}

pkg_list_installed() {
    for path in "$PKGMAN_METADATA_INSTALL_DIR/"*; do
        if [ -d "$path" ]; then
            pkg=${path#"$PKGMAN_METADATA_INSTALL_DIR/"}
            printf "%s\t%s\n" "$pkg" "$(pkg_get_installed_version "$pkg" )"
        fi
    done
}

pkg_build_depedencies() {
    for pkg do
        pkg_find_nested_deps "$pkg" |
        while read -r dep_pkg; do
            if ! pkg_is_installed "$dep_pkg"; then
                if ! pkg_is_built "$pkg" >/dev/null; then
                    pkg_build_depedencies "$dep_pkg"
                    pkg_build "$dep_pkg"
                fi
                pkg_install "$dep_pkg"
            fi
        done
    done
}

############ External commands

action_new() {
    name=$1
    version=${2:-1}
    [ ! -e "$name" ] || die "Directory already exists"
    mkdir "$name"
    echo "$version 1"   > "$name/version"
    echo "#!/bin/sh -e" > "$name/build"
    chmod +x "$name/build"

    if [ $# -gt 2 ]; then
        shift 2
        for source do
            echo "$source"     >> "$name/sources"
        done
    fi
}


action_find() {
    for pkg do
        pkg_find "$pkg"
    done
}
action_search() {
    for pattern do
        pkg_search "$pattern"
    done
}

action_download() {
    for pkg do
        pkg=$1
        path=$(pkg_find "$pkg" 1)
        version=$(pkg_read_version "$path")
        pkg_download "$pkg" "$path" "$version"
    done
}

action_extract_sources() {
    for pkg do
        pkg_extract_sources "$pkg" "${PKG_DESTDIR:-"$PWD/$pkg"}"
    done
}


_get_build_order() {
    # shellcheck disable=2030
    for pkg do
        echo "$(pkg_find_nested_deps "$pkg" | sort -u | wc -l) $pkg"
    done | sort -n | cut -d" " -f2
}

action_build() {
    # shellcheck disable=2046
    set -- $(_get_build_order "$@")
    mkdir -p "$PKGMAN_BUILD_CACHE_DIR"
    for pkg do
        pkg_build_depedencies "$pkg"
        pkg_build "$pkg"
        #if [ "$PKGMAN_AUTO_INSTALL" -eq 1 ]; then
        #    pkg_install_pkg "$pkg" 0
        #fi
    done
}

action_export() {
    archive="$(pkg_get_built "$@")"
    cp "$archive" "${PKG_DESTDIR:-.}/"
}

action_install() {
    for pkg do
        pkg_install "$pkg"
    done
}

action_remove() {
    for pkg do
        if [ "$PKGMAN_FORCE" -eq 0 ] && grep -lFxs -- "$pkg" "$PKGMAN_METADATA_DIR/"*/depends | grep -v "^__"; then
            die "$pkg has dependents"
        fi
        pkg_remove "$pkg"
    done
}

action_owns() {
    for path do
        printf "%s\t%s" "$(pkg_owns "$path")" "$path"
    done
}

action_list() {
    if [ $# -eq 0 ]; then
        pkg_list_installed
    else
        [ -d "$PKGMAN_METADATA_INSTALL_DIR" ] || return 1
        cd "$PKGMAN_METADATA_INSTALL_DIR/"
        for pattern ; do
            echo * | xargs -n1 | grep -x "$pattern" | while read -r pkg; do
                if pkg_is_installed "$pkg"; then
                    printf "%s\t%s\n" "$pkg" "$(pkg_get_installed_version "$pkg" )"
                elif [ "${PKGMAN_KEEP_GOING:-0}" -eq 0 ]; then
                    die "Could not find $pkg $pattern"
                fi
            done
        done
    fi
}

action=$1
shift
case "$action" in
    b|build) action_build "$@";;
    e|extract) action_extract_sources "$@";;
    export)    action_export "$@";;
    d|download) action_download "$@";;
    i|install) action_install "$@";;
    l|list) action_list "$@";;
    o|owns) action_owns "$@";;
    r|remove) action_remove "$@";;
    s|search) action_search "$@";;
    f|find) action_find "$@";;
    n|new) action_new "$@";;
esac
