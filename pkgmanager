#!/bin/sh -e

PKGMAN_NAME=pkgmanager
PKGMAN_ROOT="${PKGMAN_ROOT:-/}"
PKGMAN_METADATA_ROOT="${PKGMAN_METADATA_ROOT:-$PKGMAN_ROOT}"

PKGMAN_DOWNLOAD_CMD=${PKGMAN_DOWNLOAD_CMD:-curl}
PKGMAN_PATH=${PKGMAN_PATH:-$KISS_PATH}
PKGMAN_CACHE_DIR=${PKGMAN_CACHE_DIR:-${XDG_CACHE_HOME:-$HOME/.cache}/$PKGMAN_NAME}
PKGMAN_BUILD_CACHE_DIR=$PKGMAN_CACHE_DIR/build
PKGMAN_SOURCE_CACHE_DIR=${PKGMAN_SOURCE_CACHE_DIR:-$PKGMAN_CACHE_DIR/sources}

PKGMAN_METADATA_BASE_DIR=${PKGMAN_METADATA_DIR:-var/db/$PKGMAN_NAME}
PKGMAN_METADATA_BASE_INSTALL_DIR="$PKGMAN_METADATA_BASE_DIR/install"

PKGMAN_METADATA_DIR=$PKGMAN_METADATA_ROOT/$PKGMAN_METADATA_BASE_DIR
PKGMAN_METADATA_INSTALL_DIR="$PKGMAN_METADATA_ROOT/$PKGMAN_METADATA_BASE_INSTALL_DIR"
PKGMAN_METADATA_LOCK_FILE="$PKGMAN_METADATA_DIR/.lock"

PKGMAN_AUTO_INSTALL=${PKGMAN_AUTO_INSTALL:-0}
PKGMAN_FORCE=${PKGMAN_FORCE:-0}
PKGMAN_TMPDIR="${PKGMAN_TMPDIR:-/tmp/$PKGMAN_NAME}/$$"

PKGMAN_MAX_NESTED_DEPENDS="${PKGMAN_MAX_NESTED_DEPENDS:-64}"
PKGMAN_UNPRIVILEGED_USER="${PKGMAN_UNPRIVILEGED_USER:-nobody}"

PKGMAN_DEPEND_MAP_FILE=${PKGMAN_DEPEND_MAP_FILE:-"/$PKGMAN_METADATA_BASE_DIR/aliases"}
PKGMAN_HOOK_PATH="${PKGMAN_HOOK_PATH:-/etc/$PKGMAN_NAME/hooks.d}"
PKGMAN_SOURCE_FIX_FILE=${PKGMAN_SOURCE_FIX_FILE:-"/etc/$PKGMAN_NAME/source_fix"}


############## General helpers
# These methods may read global variables and all their local vairables should
# start with '_'
# They may only call methods in this category

die() {
    echo "Error: $*" >&2
    exit 2
}

info() {
    echo "$@"
}

debug() {
    [ -z "$PKGMAN_DDEBUG" ] || echo "DEBUG: $*" >&2
}

decompress() {
    case $1 in
        *.tbz|*.bz2) bzip2 -d ;;
        *.lzma)      lzma -dc ;;
        *.lz)        lzip -dc ;;
        *.tar)       cat      ;;
        *.tgz|*.gz)  gzip -d  ;;
        *.xz|*.txz)  xz -dc ;;
        *.zst)       zstd -dc ;;
    esac < "$1"
}

download_file() {
    $PKGMAN_DOWNLOAD_CMD "$1"
}

download_sources() {
    _dest="$PKGMAN_SOURCE_CACHE_DIR/$1"
    mkdir -p "$_dest"
    while read -r _url _dir; do
        _filename="$(basename "$_url")"
        if [ -n "$_dir" ]; then
            mkdir -p "$_dir"
            _filename="$_dir/$_filename"
        fi
        _fullpath="$_dest/$_filename"
        debug "checking cache for $_url"
        if [ ! -e "$_fullpath" ]; then
            debug "downloading $_url"
            download_file "$_url" > "$_fullpath.tmp"
            mv "$_fullpath.tmp" "$_fullpath"
        fi
        if [ -z "$_dir" ]; then
            echo "$_fullpath" "."
        else
            echo "$_fullpath" "$_dir"
        fi
    done
}

get_default_pkg() {
    basename "$PWD"
}

extract() {
    debug "Extracting $*"
    _fullpath=$1
    _destdir=$2
    [ -n "$_fullpath" ] && [ -n "$_destdir" ]
    case $_fullpath in
        *.tar|*.tar.*)
            decompress "$_fullpath" | tar -xf - -C "$_destdir"
        ;;
        *.zip)
            unzip "$_fullpath" -d "$_destdir"
        ;;
        *)
            cp "$_fullpath" "$_destdir"
        ;;
    esac
}

for_each_in_path() {
    _dir=$2
    # shellcheck disable=2086
    { IFS=:; set -- ${1:-"$PKGMAN_PATH"}; unset IFS; }
    for _path ; do
        [ -e "$_path/$_dir" ] || continue
        echo "$_path/$_dir"
    done
}

run_hook(){
    export TYPE="$1"
    export PKG="$2"
    debug "Running hook '$TYPE'"
    for _hook in $(for_each_in_path "$PKGMAN_HOOK_PATH") ; do
        for _script in "$_hook/"*.sh; do
            if [ -r "$_script" ]; then
                . "$_script"
            fi
        done
    done
}

############## Read state of packages
# These methods all start with "pkg_" + read/get/is/gen etc.
# Basically anything that doesn't touching disk or other state manipulation
# These methods just read state and have the same restriction has the above helpers
# int that local variables must start with _

pkg_read_version() {
    _path=$1
    _full_version=${2:-0}
    read -r _v _r<"$_path/version"
    if [ "$_full_version" -eq 0 ]; then
        echo "$_v"
    elif [ "$_full_version" -eq 1 ]; then
        echo "${_v}_$_r"
    else
        echo "$_v $_r"
    fi
}

pkg_read_full_version() {
    pkg_read_version "$1" 1
}

pkg_read_raw_version() {
    pkg_read_version "$1" 2
}

# Reads raw sources file removing blank lines and comments
pkg_read_sources() {
    [ -e "$1/sources" ] && sed '/^#/d; /^$/d' "$1/sources"
}

# Outputs the built tar; fails if package isn't built
pkg_is_built() {
    _pkg=$1
    _path=$2
    _v="$(pkg_read_full_version "$_path")"
    _archive="$PKGMAN_BUILD_CACHE_DIR/${_pkg}_${_v}.tar"
    [ -e "$_archive" ] || return 2
    echo "$_archive"
}

# Outputs the built tar; exits if package isn't built
pkg_get_built() {
    pkg_is_built "$1" "$2" || die "Package not built"
}

# Returns success if packages is installed
pkg_is_installed() {
    [ -d "$PKGMAN_METADATA_INSTALL_DIR/$1" ]
}

# Outputs the version of the installed package if package is installed
pkg_get_installed_version() {
    [ -e "$PKGMAN_METADATA_INSTALL_DIR/$1/version" ] &&
        pkg_read_raw_version "$PKGMAN_METADATA_INSTALL_DIR/$1/"
}

# Outputs a manifest file for the given directory
pkg_gen_manifest() {
    _dir=$1
    find "$_dir" | sed -e "s:$_dir::" -e '/^$/d' | sort
}

################ Business logic
# These methods can call anything in the above layer and within this layer
# However, if a method in this layer is called, it should assume
# that all of its local variables are invalidated

# Searches for the matching extensions in PATH
pkg_find_ext() {
    name=$1
    for_each_in_path "$PATH" | while read -r path; do
        if [ -x "$path/$name" ]; then
            printf "%s\t%s\n" "$name" "$path/$name"
            return
        else
            for executable in "$path/$name"*; do
                if [ -x "$executable" ]; then
                    printf "%s\t%s\n" "${executable#"$path/"}" "$executable"
                fi
            done
        fi
    done
}
# Searches "$PKGMAN_PATH" for the specified package by exact name
pkg_find() {
    target=$1
    search_path="$PKGMAN_PATH"
    [ "${PKGMANAGER_HIDE_INSTALL_DIR:-0}" -eq 1 ] || search_path=$search_path:$PKGMAN_METADATA_INSTALL_DIR
    path="$(for_each_in_path "$search_path" "$target" | head -n1)"
    [ -n "$path" ] || return 1
    echo "$path"
}

# Like find but accepts wildcards
pkg_search() {
    target=$1
    for_each_in_path "$PKGMAN_PATH" | while read -r path; do
        for pkg in "$path"/*; do
            [ -d "$pkg" ] && echo "$pkg"
        done
    done | grep "$target"
}

_pkg_find_nested_deps() {
    path=$1
    pkg="$(basename "$1")"
    max_level=$2
    level=$3
    [ -d "$path" ]
    if [ "$level" -ne 0 ]; then
        for _ in $(seq 1 "$level"); do
           printf "\t"
        done
    fi
    [ -r "$path/depends" ] || return 0
    while read -r depend label; do
        [ "#${depend#"#"}" = "$depend" ] && continue
        [ -z "$depend" ] && continue
        if [ -r "$PKGMAN_DEPEND_MAP_FILE" ]; then
            if temp=$(grep "^$depend\t" "$PKGMAN_DEPEND_MAP_FILE"); then
                depend="$(echo "$temp" | cut -f2)"
                [ -z "$depend" ] && continue
            fi
        fi
        printf "%s\t%s\n" "$depend" "$label"
        if [ "$max_level" -ne "$level" ]; then
            dep_path=$(pkg_find "$depend")
            _pkg_find_nested_deps "$dep_path" "$max_level" "$((level+1))"
        fi
    done <"$1/depends"
}

pkg_find_nested_deps() {
    SED_PATTERN=${2:+"/\s$2\$/d"}
    max_level=${3:-"$PKGMAN_MAX_NESTED_DEPENDS"}
    level=${4:-0}
    _pkg_find_nested_deps "$1" "$max_level" "$level" | sed "$SED_PATTERN"
}

pkg_find_deps() {
    pkg_find_nested_deps "$1" "$2" 0 0
}

pkg_get_build_order() {
    {
        if [ $# -eq 0 ]; then
            while read -r pkg; do
                echo "$(pkg_find_nested_deps "$pkg" | sort -u | wc -l) $pkg"
            done
        else
            for pkg do
                echo "$(pkg_find_nested_deps "$pkg" | sort -u | wc -l) $pkg"
            done
        fi
    } | sort -n | cut -d" " -f2
}

pkg_download() {
    pkg=$1
    path=$2
    version=$3
    pkg_read_sources "$path" | grep "^\w*://" |
        {
            if [ -x "$PKGMAN_SOURCE_FIX_FILE" ]; then
                $PKGMAN_SOURCE_FIX_FILE "$pkg" "$version"
            else
                cat -
            fi
        } | download_sources "$pkg"
}

pkg_extract_sources() {
    debug "Extracting sources $*"
    pkg=$1
    path=$2
    dest=$3
    [ -d "$path" ]
    version=$(pkg_read_version "$path")

    # Download in subshell to avoid risk of method modifing our
    # local vars
    (
    # Download sources first to verify we can download them
    pkg_download "$pkg" "$path" "$version" >/dev/null
    )

    mkdir -p "$dest"

    # Handle git repo next since we can't clone into a non-empty dir
    pkg_read_sources "$path" | grep "^git+" | while read -r rpath dirname; do
        git clone "${rpath#git+}" "$dest/$dirname"
    done

    # Download in subshell to avoid risk of method modifing our
    # local vars
    ( pkg_download "$pkg" "$path" "$version" ) | while read -r fullpath dirname; do
        mkdir -p "$dest/$dirname"
        tmp="$path/.tmp"
        mkdir -p "$tmp"

        extract "$fullpath" "$tmp"
        # shellcheck disable=2144
        if [ -d "$tmp"/* ]; then
            mv "$tmp"/*/* "$dest/$dirname"
            rmdir "$path/.tmp"/*
        elif [ -f "$tmp"/* ]; then
            mv "$tmp" "$dest/$dirname/$(basename "$fullpath")"
        else
            mv "$tmp" "$dest/$dirname"
        fi
    done

    # Handle local files last so they can override any of the above in case of conflicts
    pkg_read_sources "$path" | grep -v -e "^\w*://" -e "^git+"| while read -r rpath dirname; do
        if [ "git+${rpath#git+}" = "$rpath" ]; then
            git clone "${rpath#git+}" "$dest/$dirname"
        else
            cp "$path/$rpath"  "$dest/$dirname"
        fi
    done
}

pkg_build_helper() {
    pkg=$1
    path=$2

    if [ "${path#/}" = "$path" ]; then
        path="$PWD/$path"
    fi

    WORKING_DIR="$PKGMAN_TMPDIR/$pkg"
    mkdir -p  "$WORKING_DIR"
    trap 'rm -rf $WORKING_DIR' EXIT
    DEST_DIR="$WORKING_DIR/dest_dir"
    BUILD_DIR="$WORKING_DIR/build_dir"
    mkdir -p "$DEST_DIR"
    # Run in subshell to ensure validity of local variables
    ( pkg_extract_sources "$pkg" "$path" "$BUILD_DIR" )

    raw_version=$(pkg_read_raw_version "$path" )
    version="$(pkg_read_full_version "$path")"

    cd "$BUILD_DIR"

    run_hook pre-build "$pkg"

    [ -r "$path/build" ] && [ ! -x "$path/build" ] && die "$path/build exists but isn't executable"
    # actually build
    # shellcheck disable=2086
    [ -r "$path/build" ] && "$path/build" "$DEST_DIR" $raw_version
    METADATA_DIR="$DEST_DIR/$PKGMAN_METADATA_BASE_INSTALL_DIR/$pkg"
    mkdir -p "$METADATA_DIR"
    cp -R "$path"/* "$METADATA_DIR"

    debug "Version $version"
    cd "$DEST_DIR"
    run_hook post-build "$pkg"

    # todo hooks
    pkg_gen_manifest "$DEST_DIR" > "$METADATA_DIR/manifest"
    BUILD_CACHE="$PKGMAN_BUILD_CACHE_DIR/${pkg}_${version}.tar"
    debug "Saving build to $BUILD_CACHE"
    tar -c -C "$DEST_DIR" . > "$BUILD_CACHE"
}

pkg_build_single() {
    pkg=$1
    path=$2
    info "building $pkg"
    if [ "$(whoami)" != root ]; then
        ( pkg_build_helper "$pkg" "$path" )
    else
        echo "$0" _pkg_build_helper "$pkg" "$path" | {
            if [ "$USER" = root ]; then
                exec su "$PKGMAN_UNPRIVILEGED_USER"
            else
                exec su "$USER"
            fi
        }
    fi
    info "built $pkg"
}

pkg_build_depedencies() {
    target_pkg=$1
    filterStr=$2
    level=${3:-0}
    pkg_find_deps "$target_pkg" "$filterStr" |
    while read -r dep_pkg _; do
        if ! pkg_is_installed "$dep_pkg"; then
            dep_path="$(pkg_find "$dep_pkg")"
            if ! pkg_is_built "$dep_pkg" "$dep_path" >/dev/null; then
                [ "$level" -ne "$PKGMAN_MAX_NESTED_DEPENDS" ] || die "Too many nested dependencies"
                pkg_build_depedencies "$dep_path" "" "$((level+1))"
                pkg_build_single "$dep_pkg" "$dep_path"
            fi
            pkg_install "$dep_pkg" "$dep_path"
        fi
    done
}

pkg_build() {
    pkg_build_depedencies "$1"
    pkg_build_single "$1" "$2"
}

pkg_install_helper() {
    pkg=$1
    archive=$2
    WORKING_DIR="$(mktemp -d)"
    EXTRACTION_DIR="$WORKING_DIR/_fakeroot"
    trap 'rm -rf $WORKING_DIR' EXIT
    mkdir -p "$EXTRACTION_DIR"

    METADATA_DIR="$PKGMAN_METADATA_BASE_INSTALL_DIR/$pkg"
    RELATIVE_METADATA_DIR="./$METADATA_DIR"
    MANIEFST="$EXTRACTION_DIR/$RELATIVE_METADATA_DIR/manifest"

    extract "$archive" "$EXTRACTION_DIR"

    PREVIOUS_MANIFEST=$WORKING_DIR/current_manifest
    cp "$PKGMAN_METADATA_INSTALL_DIR/$pkg/manifest" "$PREVIOUS_MANIFEST" 2>/dev/null || true

    cd "$EXTRACTION_DIR"
    run_hook pre-install "$pkg" "$PREVIOUS_MANIFEST"

    cp -R "$EXTRACTION_DIR"/* "$PKGMAN_ROOT"
    # Update manifest because hooks may have changed it
    pkg_gen_manifest "$EXTRACTION_DIR" > "$PKGMAN_METADATA_INSTALL_DIR/$pkg/manifest"

    if [ -r "$PREVIOUS_MANIFEST" ]; then
        comm -13 "$PKGMAN_METADATA_INSTALL_DIR/$pkg/manifest" "$PREVIOUS_MANIFEST" | while read -r path; do
            if [ -f "$PKGMAN_ROOT/$path" ]; then
                rm "$PKGMAN_ROOT/$path"
            else
                rmdir "$PKGMAN_ROOT/$path" 2>/dev/null || true
            fi
        done
    fi

    cd "$PKGMAN_METADATA_INSTALL_DIR/$pkg"
    run_hook post-install "$pkg"
}

# Installs (or reinstalls) a package
pkg_install() {
    info "installing $1"

    # ensure non-make dependencies are built
    pkg_build_depedencies "$2" make
    if ! pkg_is_built "$1" "$2" >/dev/null; then
        pkg_build "$1" "$2"
    fi
    pkg=$1
    path=$2

    archive="$(pkg_get_built "$pkg" "$path")"
    mkdir -p "$PKGMAN_METADATA_INSTALL_DIR"
    _PKGMAN_HAS_METADATA_LOCK=1 flock "$PKGMAN_METADATA_LOCK_FILE" "$0" _pkg_install_helper "$pkg" "$archive"

    info "installed $pkg"
}

pkg_remove_helper() {
    pkg=$1
    MANIEFST="$PKGMAN_METADATA_INSTALL_DIR/$pkg/manifest"
    run_hook pre-remove "$pkg"
    sort -r "$MANIEFST" | while read -r file; do
        if [ -d "$PKGMAN_ROOT/$file" ]; then
            rmdir "$PKGMAN_ROOT/$file" 2>/dev/null || true
        else
            rm -f "$PKGMAN_ROOT/$file"
        fi
    done
    run_hook post-remove "$pkg"
}

# Removes an installed package
pkg_remove() {
    pkg=$1
    [ -d "$PKGMAN_METADATA_INSTALL_DIR/$pkg" ] || die "Package not installed"

    info "Removing $pkg"
    _PKGMAN_HAS_METADATA_LOCK=1 flock "$PKGMAN_METADATA_LOCK_FILE" "$0" _pkg_remove_helper "$pkg"

    info "Removed $pkg"

}

# List all installed packages
pkg_list_installed() {
    [ $# -eq 0 ] && set -- "$PKGMAN_METADATA_INSTALL_DIR/"*
    for path ; do
        if [ -d "$path" ]; then
            pkg=${path#"$PKGMAN_METADATA_INSTALL_DIR/"}
            read -r v r < "$PKGMAN_METADATA_INSTALL_DIR/$pkg/version"
            printf "%s\t%s\n" "$pkg" "$v $r"
        fi
    done
}

# Prints packages that whose installed version differs from repo
pkg_determine_out_of_date() {
    pkg_list_installed | while read -r pkg v r; do
        if [ "${v}_${r}" != "$(pkg_read_full_version "$pkg")" ]; then
            echo "$pkg"
        fi
    done
}

# Prints pkg and label for all installed packages that depend on the specified
# package
pkg_revdepends() {
    grep -lEs -- "^$1(\s|\$)" "$PKGMAN_METADATA_INSTALL_DIR/"*/depends | while read -r file; do
        relative_path=${file#"$PKGMAN_METADATA_INSTALL_DIR/"}
        pkg=${relative_path%"/depends"}
        if [ "${pkg#"__"}" = "$pkg" ]; then
            grep -E "^$1( |\$)" "$file" | {
                read -r _ label
                printf "%s\t%s\n" "$pkg" "$label"
            }
        fi
    done
}


############ External commands
# See the help description for a textual representation of what each does
# These methods should call pkg_X.
# Nothing should call them outside of the very last switch case

action_find() {
    [ $# -ne 0 ] || set -- "$(get_default_pkg)"
    for pkg do
        pkg_find "$pkg"
    done
}

action_search() {
    [ $# -ne 0 ] || set -- "$(get_default_pkg)"
    for pattern do
        pkg_search "$pattern"
    done
}

action_download() {
    [ $# -ne 0 ] || set -- "$(get_default_pkg)"
    for pkg do
        pkg=$1
        path=$(pkg_find "$pkg" 1)
        version=$(pkg_read_version "$path")
        pkg_download "$pkg" "$path" "$version"
    done
}

_set_pkg_path() {
    [ 0"$local_path" -eq 1 ] && path=$PWD || path="$(pkg_find "$pkg")" || path=$pkg
    pkg=$(basename "$pkg")
}

action_extract_sources() {
    [ $# -ne 0 ] || { local_path=1 && set -- "$(get_default_pkg)"; }
    for pkg do
        _set_pkg_path
        pkg_extract_sources "$pkg" "$path" "${PKG_DESTDIR:-"$PWD/$pkg"}"
    done
}


action_depends () {
    [ $# -ne 0 ] || { local_path=1 && set -- "$(get_default_pkg)"; }
    for pkg do
        _set_pkg_path
        if pkg_is_installed "$pkg"; then
            pkg_find_deps "$PKGMAN_METADATA_INSTALL_DIR/$pkg"
        else
            pkg_find_deps "$path"
        fi
    done
}

action_tree () {
    [ $# -ne 0 ] || { local_path=1 && set -- "$(get_default_pkg)"; }
    for pkg do
        _set_pkg_path
        pkg_find_nested_deps "$path"
    done
}

action_build() {
    [ $# -ne 0 ] || { local_path=1 && set -- "$(get_default_pkg)"; }
    # shellcheck disable=2046
    set -- $(pkg_get_build_order "$@")
    mkdir -p "$PKGMAN_BUILD_CACHE_DIR"
    for pkg do
        _set_pkg_path
        pkg_build "$pkg" "$path"
    done
}

action_export() {
    [ $# -ne 0 ] || { local_path=1 && set -- "$(get_default_pkg)"; }
    for pkg do
        _set_pkg_path
        (
        if ! pkg_is_built "$pkg" "$path" >/dev/null; then
            pkg_build "$pkg" "$path"
        fi
        )
        archive="$(pkg_get_built "$pkg" "$path")"
        cp "$archive" "${PKG_DESTDIR:-.}/"
    done
}

action_install() {
    [ $# -ne 0 ] || { local_path=1 && set -- "$(get_default_pkg)"; }
    mkdir -p "$PKGMAN_BUILD_CACHE_DIR"
    for pkg do
        _set_pkg_path
        pkg_install "$pkg" "$path"
    done
}

action_outdated() {
    pkg_determine_out_of_date | pkg_get_build_order
}

action_fetch() {
    for_each_in_path "$PKGMAN_PATH" ".git" | while read -r path; do
        (
            cd "$path/.."
            git pull --rebase

        ) || die "Failed to pull $path"
    done
}

action_revdepends() {
    [ $# -ne 0 ] || set -- "$(get_default_pkg)"
    for pkg do
        pkg_revdepends "$(basename "$pkg")"
    done
}

action_remove() {
    [ $# -ne 0 ] || set -- "$(get_default_pkg)"
    for pkg do
        (
        if [ "$PKGMAN_FORCE" -eq 0 ] && pkg_revdepends "$pkg" | grep -q -v "make"; then
            die "$pkg has dependents"
        fi
        )
        pkg_remove "$pkg"
    done
}

action_list() {
    if [ $# -eq 0 ]; then
        pkg_list_installed
    else
        [ -d "$PKGMAN_METADATA_INSTALL_DIR" ] || return 1
        cd "$PKGMAN_METADATA_INSTALL_DIR/"
        for pattern ; do
            pattern=${pattern%/}
            echo * | xargs -n1 | grep -x "$pattern" | while read -r pkg; do
                if pkg_is_installed "$pkg"; then
                    pkg_list_installed "$PKGMAN_METADATA_INSTALL_DIR/$pkg"
                elif [ "${PKGMAN_KEEP_GOING:-0}" -eq 0 ]; then
                    die "Could not find $pkg $pattern"
                fi
            done
        done
    fi
}

action_list_ext() {
    if [ $# -eq 0 ]; then
        pkg_find_ext pkgmanager- | sort -u -k1
    else
        for name;do
            pkg_find_ext "pkgmanager-$name" | sort -u -k1
        done
    fi
}

action_ext() {
    name="pkgmanager-$1"
    shift
    path=$(pkg_find_ext "$name" | head -n1 | cut -f1)
    [ -n "$path" ]
    exec $path "$@"
}

action=$1
shift
case "$action" in
    _pkg_build_helper)        pkg_build_helper "$@";;
    _pkg_install_helper)      pkg_install_helper "$@";;
    _pkg_remove_helper)       pkg_remove_helper "$@";;
    b|build)                  action_build "$@";;
    do*)                      action_download "$@";;
    d|depends)                action_depends "$@";;
    export)                   action_export "$@";;
    e|extract)                action_extract_sources "$@";;
    fetch)                    action_fetch "$@";;
    find)                     action_find "$@";;
    get-metadata-install-dir) echo "$PKGMAN_METADATA_INSTALL_DIR/$1";;
    i|install)                action_install "$@";;
    list-ext)                 action_list_ext "$@" ;;
    l|list)                   action_list "$@";;
    outdated)                 action_outdated "$@";;
    rev*)                     action_revdepends "$@";;
    r|remove)                 action_remove "$@";;
    s|search)                 action_search "$@";;
    t|tree)                   action_tree "$@";;
    *)                        action_ext "$action" "$@" ;;
esac
